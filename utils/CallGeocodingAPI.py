#!/usr/bin/python3

############################################################################
#
# File: CallGeocodingAPI.py
# Last Edit: 2015-03-16
# Author: Matthew Leeds <mwl458@gmail.com>
# License: GNU GPL <http://www.gnu.org/licenses/gpl.html>
# Purpose: Read the files generated by GenerateContributorsAndPayees.py
# and convert addresses to coordinates using Google's Geocoding API.
# Also we try to locate people by county, district, etc.
# The Google Maps API documentation is here:
# https://developers.google.com/maps/documentation/geocoding/
# You'll need to make a "Simple API key for server apps" here:
# https://code.google.com/apis/console/?noredirect
# 
# There's also a function, geocodeOSM, for using the OpenStreetMap.org API:
# http://wiki.openstreetmap.org/wiki/Nominatim
#
############################################################################

import csv
import json
from urllib.request import urlopen
from urllib.parse import urlencode
from time import sleep, time
from shapely.geometry import Point, shape

# file names
CONTRIBS_FILE = '2014_Contributors.json'
PAYEES_FILE = '2014_Payees.json'
STATE_FILE = 'AL.geojson'
COUNTIES_FILE = 'AL_Counties.geojson'
UPPER_DISTRICTS = 'sldu-simple.json'
LOWER_DISTRICTS = 'sldl-simple.json'
# email address parameter for OSM
EMAIL_ADDRESS = 'YOUR_EMAIL'
# google API Key
API_KEY = 'YOUR_API_KEY'
MAX_API_REQUESTS = 2500 # per day
# an estimated minimum bounding rectangle around Alabama formatted for Google
ALABAMA_BOUNDS = '35.046674,-88.751659|30.077183,-84.687088'
# formatted for OSM
ALABAMA_BOUNDS_OSM = '-88.7,35.09,-84.79,30.06'
# it's not worth trying to geocode addresses containing these strings
BAD_ADDRESSES = ['NOT KNOWN', 'PO BOX', 'P.O. BOX', 'P O BOX', 'P. O. BOX', 'P.O.BOX', 'POST OFFICE BOX']
PRETTY_PRINT = True # controls JSON output formatting

def main():
    global numAPIRequests
    numAPIRequests = 0 # keep track so we don't exceed usage limits
    global allContributors
    allContributors = []
    global allPayees
    allPayees = []
    modifiedRecords = False # keep track of whether we update any
    # Check if there are any contributors that need geocoding.
    print('>> Loading ' + CONTRIBS_FILE + '.')
    with open('data/' + CONTRIBS_FILE) as datafile:
        allContributors = json.load(datafile)
    (success, modifiedRecords) = geocodeEntities(True) # True means look at Contributors
    # Check if there are any payees that need geocoding.
    print('>> Loading ' + PAYEES_FILE)
    with open('data/' + PAYEES_FILE) as datafile:
        allPayees = json.load(datafile)
    # if we already had a fatal error stop trying
    if success: 
        (success, modifiedRecords) = geocodeEntities(False) # False means look at Payees
    # export the data to the files it came from (if we modified any)
    if modifiedRecords:
        with open('data/' + CONTRIBS_FILE, 'w') as output:
            if PRETTY_PRINT: 
                json.dump(allContributors, output, sort_keys=True, indent=4, separators=(',', ': '))
            else:
                json.dump(allContributors, output)
        with open('data/' + PAYEES_FILE, 'w') as output:
            if PRETTY_PRINT:
                json.dump(allPayees, output, sort_keys=True, indent=4, separators=(',', ': '))
            else:
                json.dump(allPayees, output)

def geocodeEntities(contribsOrPayees):
    modifiedAny = False # return value
    success = True # return value
    # load state geojson
    with (open('data/map/' + STATE_FILE)) as f:
        s = json.load(f)
    stateShape = shape(s['features'][0]['geometry'])
    # load counties geojson
    with (open('data/map/' + COUNTIES_FILE)) as f:
        c = json.load(f)
    Counties = {}
    for county in c['features']:
        Counties[county['properties']['name']] = shape(county['geometry'])
    # load senate districts geojson
    with (open('data/map/' + UPPER_DISTRICTS)) as f:
        u = json.load(f)
    senateDistricts = {}
    for district in u['geometries']:
        senateDistricts[district['district']] = shape(district)
    # load house districts geojson
    with (open('data/map/' + LOWER_DISTRICTS)) as f:
        l = json.load(f)
    houseDistricts = {}
    for district in l['geometries']:
        houseDistricts[district['district']] = shape(district)
    for record in (allContributors if contribsOrPayees else allPayees):
        # don't touch records that have already been geocoded
        if len(record['_API_status']) > 0:
            continue
        # don't bother asking Google about an empty address or PO BOX, etc.
        if len(record['address']) == 0 and not checkString(record['address'], BAD_ADDRESSES):
            modifiedAny = True
            record['_API_status'] = 'ZERO_RESULTS'
        # otherwise we should try to geocode it
        else:
            modifiedAny = True
            result = geocodeGoogle(record['address']) # make the request to Google 
            #result = geocodeOSM(address) # make the request to OSM
            numAPIRequests += 1
            if isinstance(result, str):
                print('Error: ' + result)
                if result == 'REQUEST_DENIED' or result == 'OVER_QUERY_LIMIT':
                    success = False
                    break # give up
                # save the status code so we don't try again (usually ZERO_RESULTS)
                record['_API_status'] = result
            else: # success
                record['address'] = result[1] # nicely formatted address
                # round coordinates to 6 decimal places (~0.1m precision)
                record['geo_data'] = [round(result[0]['lat'], 6),
                                      round(result[0]['lng'], 6)]
                record['_API_status'] = 'OK'
                # Now use the new information to try to find their county, district, etc.
                record['in_state'] = 0
                thisPoint = Point(record['geo_data'][0], record['geo_data'][1])
                if stateShape.contains(thisPoint): 
                    record['in_state'] = 1
                    for countyName in Counties:
                        if Counties[countyName].contains(thisPoint):
                            record['county'] = countyName
                            break
                    for senateDistrictName in senateDistricts:
                        if senateDistricts[senateDistrictName].contains(thisPoint):
                            record['senate_district'] = senateDistrictName[16:]
                            break
                    for houseDistrictName in houseDistricts:
                        if houseDistricts[houseDistrictName].contains(thisPoint):
                            record['house_district'] = houseDistrictName[15:]
                            break
    return (success, modifiedAny)

# uses the Google Maps API to geocode an address
# on success: returns a tuple with the coordinates and the formatted address
# on failure: returns the status code (a string)
def geocodeGoogle(address):
    # the bounds parameter biases results to locations within Alabama
    params = {'address': address, 
              'bounds': ALABAMA_BOUNDS,
              'key': API_KEY}
    url = 'https://maps.googleapis.com/maps/api/geocode/json?' + urlencode(params, safe='/,|')
    rawreply = urlopen(url).read()
    reply = json.loads(rawreply.decode('utf-8'))
    sleep(0.1) # stay under usage limit
    # assume the first result is correct
    if reply['status'] == 'OK':
        return (reply['results'][0]['geometry']['location'], reply['results'][0]['formatted_address'])
    else:
        return reply['status']

# uses the OpenStreetMap.org "Nominatim" geocoding service via MapQuest
# return values should match the format that the Google Maps function returns
def geocodeOSM(address):
    params = {'q': address,
              'format': 'json',
              'email': EMAIL_ADDRESS,
              'viewbox': ALABAMA_BOUNDS_OSM,
              'limit': '1',
              'addressdetails': '0'}
    url = 'http://open.mapquestapi.com/nominatim/v1/search.php?' + urlencode(params)
    rawreply = urlopen(url).read()
    reply = json.loads(rawreply.decode('utf-8'))
    sleep(1)
    try:
        coords = {'lat': reply[0]['lat'], 'lng': reply[0]['lon']}
        niceAddress = reply[0]['display_name']
        result = (coords, niceAddress)
    except:
        result = 'NO_RESULTS_FOUND'
    return result

# takes in a string and a blacklist and returns false if there are any matches
def checkString(string, blacklist):
    for phrase in blacklist:
        if phrase in string:
            return False
    return True

if __name__=='__main__':
    main()
