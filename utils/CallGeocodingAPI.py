#!/usr/bin/python3

############################################################################
#
# File: CallGeocodingAPI.py
# Last Edit: 2015-04-16
# Author: Matthew Leeds <mwl458@gmail.com>
# License: GNU GPL <http://www.gnu.org/licenses/gpl.html>
# Purpose: Read the files generated by GenerateTransactees.py
# and convert addresses to coordinates using Google's Geocoding API.
# Also we try to locate people by county, district, etc.
# The Google Maps API documentation is here:
# https://developers.google.com/maps/documentation/geocoding/
# You'll need to make a "Simple API key for server apps" here:
# https://code.google.com/apis/console/?noredirect
# There's also a function, geocodeOSM, for using the OpenStreetMap.org API:
# http://wiki.openstreetmap.org/wiki/Nominatim
# Configuration parameters are read from 'config.ini'.
# This depends on the shapely library, which depends on GEOS library.
# Try 'apt-get install -y libgeos-dev && pip install shapely' on Ubuntu.
#
############################################################################

import sys
import csv
import json
from urllib.request import urlopen
from urllib.parse import urlencode
from time import sleep
from shapely.geometry import Point, shape
from configparser import ConfigParser

def main():
    global config
    config = ConfigParser()
    config.read('config.ini')
    DATA_DIR = config.get('CALL_GEOCODING', 'DATA_DIR')
    TRANSACTEES_FILE = config.get('GENERATE_TRANSACTEES', 'OUTFILE') + '.json'
    USE_GOOGLE = config.getboolean('CALL_GEOCODING', 'USE_GOOGLE')
    if USE_GOOGLE and len(config.get('CALL_GEOCODING', 'API_KEY')) == 0:
        print('>> To use Google\'s Geocoding API, you must have an API key!')
        sys.exit(1)
    elif not USE_GOOGLE and len(config.get('CALL_GEOCODING', 'EMAIL_ADDRESS')) == 0:
        print('>> To use OSM\'s Geocoding API, you must have an email address!')
        sys.exit(1)
    PRETTY_PRINT = config.getboolean('CALL_GEOCODING', 'PRETTY_PRINT')
    global numAPIRequests
    numAPIRequests = 0 # keep track so we don't exceed usage limits
    global allTransactees
    allTransactees = []
    modifiedRecords = False # keep track of whether we update any
    # Check if there are any transactees that need geocoding.
    print('>> Loading ' + TRANSACTEES_FILE + '...', end='')
    with open(DATA_DIR + TRANSACTEES_FILE) as datafile:
        allTransactees = json.load(datafile)
    print(str(len(allTransactees)) + ' records loaded.')
    (success, modifiedRecords) = geocodeTransactees(USE_GOOGLE)
    # Write the data out if we modified anything.
    if modifiedRecords:
        print('>> Writing modified records to ' + TRANSACTEES_FILE + '.')
        with open(DATA_DIR + TRANSACTEES_FILE, 'w') as output:
            if PRETTY_PRINT: 
                json.dump(allTransactees, output, sort_keys=True, indent=4, separators=(',', ': '))
            else:
                json.dump(allTransactees, output)
    else:
        print('>> No records were modified.')
    if not success:
        sys.exit(1)

def geocodeTransactees(googleOrOSM):
    global config
    global allTransactees
    global numAPIRequests
    modifiedAny = False # return value
    success = True # return value
    MAP_DIR = config.get('CALL_GEOCODING', 'MAP_DIR')
    # load state geojson
    STATE_FILE = config.get('CALL_GEOCODING', 'STATE_FILE')
    with (open(MAP_DIR + STATE_FILE)) as f:
        s = json.load(f)
    stateShape = shape(s['features'][0]['geometry'])
    # load counties geojson
    COUNTIES_FILE = config.get('CALL_GEOCODING', 'COUNTIES_FILE')
    with (open(MAP_DIR + COUNTIES_FILE)) as f:
        c = json.load(f)
    Counties = {}
    for county in c['features']:
        Counties[county['properties']['name']] = shape(county['geometry'])
    # load senate districts geojson
    UPPER_DISTRICTS = config.get('CALL_GEOCODING', 'UPPER_DISTRICTS')
    with (open(MAP_DIR + UPPER_DISTRICTS)) as f:
        u = json.load(f)
    senateDistricts = {}
    for district in u['geometries']:
        senateDistricts[district['district']] = shape(district)
    # load house districts geojson
    LOWER_DISTRICTS = config.get('CALL_GEOCODING', 'LOWER_DISTRICTS')
    with (open(MAP_DIR + LOWER_DISTRICTS)) as f:
        l = json.load(f)
    houseDistricts = {}
    for district in l['geometries']:
        houseDistricts[district['district']] = shape(district)
    BAD_ADDRESSES = json.loads(config.get('CALL_GEOCODING', 'BAD_ADDRESSES'))
    MAX_API_REQUESTS = config.getint('CALL_GEOCODING', 'MAX_API_REQUESTS')
    VERBOSE = config.getboolean('CALL_GEOCODING', 'VERBOSE')
    for record in allTransactees:
        # don't touch records that have already been geocoded
        if len(record['_API_status']) > 0:
            continue
        # don't bother asking Google about an empty address or PO BOX, etc.
        if len(record['address']) == 0 and not checkString(record['address'], BAD_ADDRESSES):
            modifiedAny = True
            record['_API_status'] = 'ZERO_RESULTS'
        # otherwise we should try to geocode it
        elif numAPIRequests < MAX_API_REQUESTS:
            if VERBOSE:
                print('>> Requesting info for ' + record['address'])
            modifiedAny = True
            if googleOrOSM:
                result = geocodeGoogle(record['address'])
            else:
                result = geocodeOSM(address)
            numAPIRequests += 1
            if isinstance(result, str): # failure
                print('Error: ' + result)
                if result == 'REQUEST_DENIED' or result == 'OVER_QUERY_LIMIT':
                    success = False
                    break # give up
                # save the status code so we don't try again (usually ZERO_RESULTS)
                record['_API_status'] = result
            else: # success
                record['address'] = result[1] # nicely formatted address
                # round coordinates to 6 decimal places (~0.1m precision)
                record['geo_data'] = [round(result[0]['lat'], 6),
                                      round(result[0]['lng'], 6)]
                record['_API_status'] = 'OK'
                # Now use the new information to try to find their county, district, etc.
                record['in_state'] = 0
                thisPoint = Point(record['geo_data'][0], record['geo_data'][1])
                if stateShape.contains(thisPoint): 
                    record['in_state'] = 1
                    for countyName in Counties:
                        if Counties[countyName].contains(thisPoint):
                            record['county'] = countyName
                            break
                    for senateDistrictName in senateDistricts:
                        if senateDistricts[senateDistrictName].contains(thisPoint):
                            record['senate_district'] = senateDistrictName[16:]
                            break
                    for houseDistrictName in houseDistricts:
                        if houseDistricts[houseDistrictName].contains(thisPoint):
                            record['house_district'] = houseDistrictName[15:]
                            break
        else: # numAPIRequests == MAX_API_REQUESTS
            print('>> Error: Configured API request limit reached (' + str(MAX_API_REQUESTS) + ')')
            success = False
            break
    return (success, modifiedAny)

# uses the Google Maps API to geocode an address
# on success: returns a tuple with the coordinates and the formatted address
# on failure: returns the status code (a string)
def geocodeGoogle(address):
    global config
    ALABAMA_BOUNDS = config.get('CALL_GEOCODING', 'ALABAMA_BOUNDS')
    API_KEY = config.get('CALL_GEOCODING', 'API_KEY')
    BASE_URL = config.get('CALL_GEOCODING', 'BASE_URL')
    # the bounds parameter biases results to locations within Alabama
    params = {'address': address, 
              'bounds': ALABAMA_BOUNDS,
              'key': API_KEY}
    url = BASE_URL + urlencode(params, safe='/,|')
    rawreply = urlopen(url).read()
    reply = json.loads(rawreply.decode('utf-8'))
    sleep(0.1) # stay under usage limit
    # assume the first result is correct
    if reply['status'] == 'OK':
        return (reply['results'][0]['geometry']['location'], reply['results'][0]['formatted_address'])
    else:
        return reply['status']

# uses the OpenStreetMap.org "Nominatim" geocoding service via MapQuest
# return values should match the format that the Google Maps function returns
def geocodeOSM(address):
    global config
    EMAIL_ADDRESS = config.get('CALL_GEOCODING', 'EMAIL_ADDRESS')
    ALABAMA_BOUNDS_OSM = config.get('CALL_GEOCODING', 'ALABAMA_BOUNDS_OSM')
    BASE_URL_OSM = config.get('CALL_GEOCODING', 'BASE_URL_OSM')
    params = {'q': address,
              'format': 'json',
              'email': EMAIL_ADDRESS,
              'viewbox': ALABAMA_BOUNDS_OSM,
              'limit': '1',
              'addressdetails': '0'}
    url = BASE_URL_OSM + urlencode(params)
    rawreply = urlopen(url).read()
    reply = json.loads(rawreply.decode('utf-8'))
    sleep(1) # rate limit ourselves
    try:
        coords = {'lat': reply[0]['lat'], 'lng': reply[0]['lon']}
        niceAddress = reply[0]['display_name']
        result = (coords, niceAddress)
    except:
        result = 'NO_RESULTS_FOUND'
    return result

# takes in a string and a blacklist and returns false if there are any matches
def checkString(string, blacklist):
    for phrase in blacklist:
        if phrase in string:
            return False
    return True

if __name__=='__main__':
    main()
